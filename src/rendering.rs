mod shader_objects;

use std::{collections::HashMap, ops::Deref, path::PathBuf};

use wgpu::{naga::back::msl::sampler, Device, RenderPipelineDescriptor, ShaderModule, Surface, SurfaceTexture, VertexBufferLayout};
use winit::{dpi::{PhysicalPosition, PhysicalSize}, event::{AxisId, DeviceId, ElementState, Ime, InnerSizeWriter, KeyEvent, Modifiers, MouseButton, MouseScrollDelta, Touch, TouchPhase}};

use crate::{gpu::GpuConnection, HeatwaveApp};

///A user defined handler of window events. Almost all events are optional functions.
///Please see the [documentation](`Presenter`) to see what events are available.
pub trait Presenter {
	type RenderData: Clone + Send + 'static;

	///Called whenever the app wants to close. After this finished execution, the window will be killed.
	fn on_exit(&mut self) {}
	///Called whenever the mouse cursor enters the bounds of the window.
	fn on_cursor_enter(&mut self, device_id: DeviceId) {}
	///Called whenever the mouse cursor moves within the bounds of the window.
	fn on_cursor_move(&mut self, device_id: DeviceId, position: PhysicalPosition<f64>) {}
	///Called whenever the mouse cursor leaves the bounds of the window.
	fn on_cursor_leave(&mut self, device_id: DeviceId) {}
	///Requests the presenter to make draw calls to the GPU as to provide the next frame of the app.
	fn render(data: Self::RenderData, helper: Option<RenderHelper>);
	///Pack the data you require into the RenderData.
	fn package_render_data(&mut self) -> Self::RenderData;
	///Called whenever the window's client region is resized
	fn on_window_resize(&mut self, new_size: PhysicalSize<u32>) {}
	///Called whenever the window's position changes
	fn on_window_move(&mut self, new_position: PhysicalPosition<i32>) {}
	///Called whenever the user drops a file on the window. Calls multiple times for multiple files 
	fn on_file_drop(&mut self, path: PathBuf) {}
	///Called whenever the user hovers one or more files over the window. Calls multiple times for multiple files
	fn on_file_hover(&mut self, path: PathBuf) {}
	///Called whenever the user cancels a file hover over the window. Calls once regardless of file count
	fn on_file_hover_cancel(&mut self) {}
	///Called whenever the window is focused or unfocused
	fn on_window_focus_changed(&mut self, focused: bool) {}
	///Called whenever a key on the keyboard is pressed
	fn on_key_press(&mut self, args: KeyPressEventArgs) {}
	///Called whenever a key on the keyboard is released
	fn on_key_release(&mut self, args: KeyPressEventArgs) {}
	///Called whenever the modifiers held on the keyboard change (Shift, Ctrl, etc.)
	fn on_modifier_changed(&mut self, modifiers: Modifiers) {}
	///Called whenever the user starts typing a character via Ime (multi-keypress characters)
	fn on_ime_input(&mut self, ime: Ime) {}
	///Called whenever the scroll wheel moves
	fn on_mouse_scroll(&mut self, args: MouseScrollEventArgs) {}
	///Called whenever the user presses a mouse button
	fn on_mouse_down(&mut self, args: MousePressEventArgs) {}
	///Called whenever the user releases a mouse button
	fn on_mouse_up(&mut self, args: MousePressEventArgs) {}
	///Called whenever some analog control device (such as a joystick or gamepad) changes stick position
	fn on_analog_axis_motion(&mut self, args: AnalogAxisEventArgs) {}
	///Called whenever the window's scale factor changes (DPI change, scale change etc.)
	fn on_scale_factor_change(&mut self, new_scale_factor: f64, writer: InnerSizeWriter) {}
	///Called whenever the window is fully hidden from view
	fn on_occlusion(&mut self, occluded: bool) {}
	///Called whenever the window was touched on a touch screen
	fn on_touch(&mut self, touch: Touch) {}
}
///Event data relating to keyboard inputs
pub struct KeyPressEventArgs {
	///The ID of the device that sent the signal
	pub device_id: DeviceId,
	///Information about the key that was operated
	pub event: KeyEvent,
	///Is true if the keypress was generated by winit under certain edge cases
	pub is_synthetic: bool
}
///Event data relating to scrolling
pub struct MouseScrollEventArgs {
	///The ID of the device that sent the signal
	pub device_id: DeviceId,
	///The difference between the previous and current scroll states
	pub delta: MouseScrollDelta,
	///Where in the motion of scrolling this event was raised
	pub phase: TouchPhase
}
///Event data relating to mouse button presses
pub struct MousePressEventArgs {
	///The ID of the device that sent the signal 
	pub device_id: DeviceId,
	///The new state of the button that was operated
	pub state: ElementState,
	///The button that was operated
	pub button: MouseButton,
	///The position of the mouse cursor at the time of the event
	pub position: PhysicalPosition<f64>
}
///Event data relating to analog axis motion
pub struct AnalogAxisEventArgs {
	///The ID of the device that sent the signal
	pub device_id: DeviceId,
	///The id of the axis the motion occurred on
	pub axis: AxisId,
	///The new value of the axis
	pub value: f64
}

///Provides all the components the user might need to perform any form of render operation
///
///The functions provided by RenderHelper are there to simplify rendering, and they do not provide any real advantage over using wpgu rendering manually.
pub struct RenderHelper<'a> {
	pub surface: &'a Surface<'a>,
	pub texture: SurfaceTexture,
	pub depth_texture: &'a Texture,
	pub device: &'a Device,

	pub render_pipelines: &'a HashMap<usize, wgpu::RenderPipeline>,
	pub compute_pipelines: &'a HashMap<usize, wgpu::ComputePipeline>,

	pub background: wgpu::Color
}
impl<'a> RenderHelper<'a> {
	pub fn new(window: &'a HeatwaveApp) -> Self {
		RenderHelper {
			surface: window.connection().surface(),
			texture: window.connection().surface().get_current_texture().expect("Texture reference already exists that references this connection's surface"),
			device: window.connection().device(),
			render_pipelines: &window.render_pipelines,
			compute_pipelines: &window.compute_pipelines,
			background: window.skybox,
			depth_texture: window.connection().depth_texture()
		}
	}

	///Runs the specified compute pipelines on the GPU
	///
	///Todo: Figure out how to return the value to the user
	pub fn compute_with_pipelines(&self, ids: &[&usize]) {
		
	}
	///Runs all compute pipelines on the GPU
	pub fn compute_all_pipelines(&self) {
		self.compute_with_pipelines(self.compute_pipelines.into_keys().collect::<Vec<_>>().deref())
	}
	///Runs the specified rendering pipelines on the GPU
	///Loads the skybox in the 
	pub fn render_with_pipelines(&self, ids: &[&usize]) {
		let view = self.texture.texture.create_view(&wgpu::TextureViewDescriptor::default());

		let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
			label: Some("Heatwave Rendering Encoder")
		});

		let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
			label: Some("Heatwave Render Pass"),
			color_attachments: &[Some(wgpu::RenderPassColorAttachment {
				view: &view,
				resolve_target: None,
				ops: wgpu::Operations {
					load: wgpu::LoadOp::Clear(self.background),
					store: wgpu::StoreOp::Store
				}
			})],
			depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
				view: &self.depth_texture.view,
				depth_ops: Some(wgpu::Operations {
					load: wgpu::LoadOp::Clear(1.0),
					store: wgpu::StoreOp::Store
				}),
				stencil_ops: None
			}),
			timestamp_writes: None,
			occlusion_query_set: None
		});
	}
	///Runs all rendering pipelines on the GPU
	pub fn render_all_pipelines(&self) {
		self.render_with_pipelines(self.render_pipelines.into_keys().collect::<Vec<_>>().deref())
	}
}

pub trait ShaderObject {
	fn layout() -> wgpu::VertexBufferLayout<'static>;
}


///Describes the properties for a new [`wgpu::RenderPipeline`] with some abstractions made for an easier user experience
/// 
/// 
///# Remarks
/// ## Conversion
/// When converting to [`wgpu::RenderPipelineDescriptor`], optional parameters are defaulted to None.\ The [`HeatwaveWindow`] will fill some of these in with more reasonable values, but you will need to handle it yourself if you need more granular control.
///# Assumptions
/// This struct makes quite a few assumptions to give an easier, more generalised descriptor for common usage\
/// The assumptions listed below are assumptions made in your typical game engine, which are replicated for Heatwave.
/// - The fragment shader overwrites old pixels
/// - The fragment shader accesses all colour channels
/// - The topology is a triangle list
/// - The front face is the counter clockwise side
/// - Culls the back faces
/// - Depth clipping is enabled, though will be disabled by default if the [`wgpu_types::Features::DEPTH_CLIP_CONTROL`] feature is enabled
/// - Polygons will rasterise in fill mode, by default.
/// - Conservative rasterisation is disabled by default, but enabled if [`wgpu_types::Features::CONSERVATIVE_RASTERIZATION`] is enabled (Any pixel touched by the polygon is filled, rather than only if most of the pixel is touched)
/// - Assumes only 1 view is needed 
///# Usage
///```rs
/// let descriptor = SimpleRenderPipelineDescriptor {
///     name: "My Render Pipeline",
///     vertex: &my_vertex_shader_module,
///     fragment: Some(&my_fragment_shader_module), //This can be the same as the vertex shader
///     vertex_entry_point: "vs_main",
///     fragment_entry_point: "fs_main",
///     vertex_buffer_format: config.format
/// }
///                          
/// let my_pipeline_id = my_heatwave_window.add_render_pipeline(descriptor);
///```
pub struct SimpleRenderPipelineDescriptor<'a> {
	///The name of the pipeline. Used for debugging
	pub name: &'a str,
	///The module for the vertex shader
	pub vertex: &'a ShaderModule,
	///The module for the fragment shader. Technically optional but it's recommended to have one
	pub fragment: Option<&'a ShaderModule>,
	///The name of the entry point function for the vertex shader within the shader module
	pub vertex_entry_point: &'a str,
	///The name of the entry point function for the fragment shader within the shader module
	pub fragment_entry_point: Option<&'a str>,
	///The format of any vertex buffers used by the pipeline
	pub vertex_buffer_format: &'a [VertexBufferLayout<'a>],
}
impl<'a> From<SimpleRenderPipelineDescriptor<'a>> for RenderPipelineDescriptor<'a> {
	///Converts a SimpleRenderPipelineDescriptor into a RenderPipelineDescriptor.
	/// 
	/// It is missing the following information:\
	/// * layout (Needs pipeline layout from the heatwave window)
	/// * color states of the fragment shader's render targets (Needs formats from the surfaces)
	/// 
	/// This information is automatically filled in when adding it to a HeatwaveWindow
    fn from(val: SimpleRenderPipelineDescriptor<'a>) -> Self {
        RenderPipelineDescriptor {
			label: Some(val.name),
			layout: None,
			vertex: wgpu::VertexState {
				module: val.vertex,
				entry_point: val.vertex_entry_point,
				buffers: val.vertex_buffer_format
			},
			fragment: val.fragment.map(|fragment| wgpu::FragmentState {
				module: fragment,
				entry_point: val.fragment_entry_point.expect("Expected fragment entry point name for the fragment shader"),
				targets: &[],
			}),
			primitive: wgpu::PrimitiveState {
				topology: wgpu::PrimitiveTopology::TriangleList,
				strip_index_format: None,
				front_face: wgpu::FrontFace::Ccw,
				cull_mode: Some(wgpu::Face::Back),
				unclipped_depth: false,
				polygon_mode: wgpu::PolygonMode::Fill,
				conservative: false 
			},
			 depth_stencil: Some(wgpu::DepthStencilState {
			 	format: Texture::DEPTH_FORMAT,
				depth_write_enabled: true,
				depth_compare: wgpu::CompareFunction::Less,
				stencil: wgpu::StencilState::default(),
				bias: wgpu::DepthBiasState::default()
			}),
			multisample: wgpu::MultisampleState {
				count: 8,
				mask: !0,
				alpha_to_coverage_enabled: false
			},
			multiview: None
		}
    }
}

pub struct Texture {
	pub texture: wgpu::Texture,
	pub view: wgpu::TextureView,
	pub sampler: wgpu::Sampler
}
impl Texture {
	pub const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth32Float;

	pub fn create_depth_texture(device: &wgpu::Device, config: &wgpu::SurfaceConfiguration, label: &str) -> Self {
		let size = wgpu::Extent3d {
			width: config.width,
			height: config.height,
			depth_or_array_layers: 1
		};
		let desc = wgpu::TextureDescriptor {
			label: Some(label),
			size,
			mip_level_count: 1,
			sample_count: 1,
			dimension: wgpu::TextureDimension::D2,
			format: Self::DEPTH_FORMAT,
			usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
			view_formats: &[]
		};
		let texture = device.create_texture(&desc);

		let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
		let sampler = device.create_sampler(
			&wgpu::SamplerDescriptor {
				address_mode_u: wgpu::AddressMode::ClampToBorder,
				address_mode_v: wgpu::AddressMode::ClampToBorder,
				address_mode_w: wgpu::AddressMode::ClampToBorder,
				mag_filter: wgpu::FilterMode::Linear,
				min_filter: wgpu::FilterMode::Linear,
				mipmap_filter: wgpu::FilterMode::Nearest,
				compare: Some(wgpu::CompareFunction::LessEqual),
				lod_min_clamp: 0.0,
				lod_max_clamp: 100.0,
        		..Default::default()
			}
		);

		Self {
			texture,
			view,
			sampler
		}
	}
}
